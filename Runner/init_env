#!/bin/sh

# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# Idempotency guard: only initialize ONCE per shell session
[ -n "$__INIT_ENV_LOADED" ] && return
__INIT_ENV_LOADED=1

# (Optional) Remove/comment log line below to keep CI logs clean:
# echo "[INFO] init_env loaded."

# --- Robust root detection ---
if [ -z "$ROOT_DIR" ]; then
    # Fast path: current working directory is root
    if [ -d "./utils" ] && [ -d "./suites" ]; then
        ROOT_DIR="$(pwd)"
    else
        # Fallback: walk up from this script's location
        _script_dir="$(cd "$(dirname "$0")" && pwd)"
        _search="$_script_dir"
        while [ "$_search" != "/" ]; do
            if [ -d "$_search/utils" ] && [ -d "$_search/suites" ]; then
                ROOT_DIR="$_search"
                break
            fi
            _search=$(dirname "$_search")
        done
    fi
fi

# --- Validate and export key environment paths ---
if [ -z "${ROOT_DIR:-}" ] || [ ! -d "$ROOT_DIR/utils" ] || [ ! -f "$ROOT_DIR/utils/functestlib.sh" ]; then
    echo "[ERROR] Could not detect testkit root (missing utils/ or functestlib.sh)" >&2
    exit 1
fi

export ROOT_DIR
export TOOLS="$ROOT_DIR/utils"
export __RUNNER_SUITES_DIR="$ROOT_DIR/suites"
export __RUNNER_UTILS_BIN_DIR="$ROOT_DIR/common"

# --- Ensure TOOLS is usable in all shells ---
case ":$PATH:" in
  *":$TOOLS:"*) : ;;
  *)
    PATH="$TOOLS:$PATH"
    export PATH
    ;;
esac

# --- Optional: pre-check for required tools (safe no-op for minimal builds) ---
if [ -f "$TOOLS/functestlib.sh" ]; then
    # shellcheck disable=SC1090,SC1091
    . "$TOOLS/functestlib.sh" >/dev/null 2>&1 || true
fi

###############################################################################
# Stdout/stderr capture (per-test folder)
#
# Controls (set BEFORE sourcing this file):
# RUN_STDOUT_ENABLE = 1 | 0 (default: 1)
# RUN_STDOUT_TAG = <string> (default: basename of $PWD)
# RUN_STDOUT_FILE = <path> (default: $PWD/<tag>_stdout_<ts>.log)
#
# Behavior:
# - Writes the capture file into the CURRENT DIRECTORY (usually the test dir).
# - No global logs/stdout directory is created/used.
###############################################################################
_runner_stdout_cleanup() {
    st=$?
    # restore original fds (if they were saved)
    exec 1>&3 2>&4
    if [ -n "${__TEE_PID:-}" ]; then
        kill "$__TEE_PID" 2>/dev/null
    fi
    if [ -n "${PIPE:-}" ]; then
        rm -f "$PIPE" 2>/dev/null
    fi
    exit "$st"
}

if [ "${RUN_STDOUT_ENABLE:-1}" -eq 1 ] && [ -z "${__RUN_STDOUT_ACTIVE:-}" ]; then
    _tag="${RUN_STDOUT_TAG:-$(basename "$(pwd)")}"
    _ts="$(date +%Y%m%d-%H%M%S)"
    RUN_STDOUT_FILE="${RUN_STDOUT_FILE:-$(pwd)/${_tag}_stdout_${_ts}.log}"
    export RUN_STDOUT_FILE

    # Save original stdout/stderr
    exec 3>&1 4>&2

    if command -v tee >/dev/null 2>&1; then
        PIPE="$(mktemp -u "/tmp/stdout_pipe.XXXXXX")"
        if mkfifo "$PIPE" 2>/dev/null; then
            ( tee -a "$RUN_STDOUT_FILE" >&3 ) < "$PIPE" &
            __TEE_PID=$!
            exec > "$PIPE" 2>&1
            __RUN_STDOUT_ACTIVE=1
            trap _runner_stdout_cleanup EXIT INT TERM
        else
            # Fallback: file-only capture
            exec >> "$RUN_STDOUT_FILE" 2>&1
            __RUN_STDOUT_ACTIVE=1
            trap _runner_stdout_cleanup EXIT INT TERM
        fi
    else
        # Fallback: file-only capture
        exec >> "$RUN_STDOUT_FILE" 2>&1
        __RUN_STDOUT_ACTIVE=1
        trap _runner_stdout_cleanup EXIT INT TERM
    fi
fi
