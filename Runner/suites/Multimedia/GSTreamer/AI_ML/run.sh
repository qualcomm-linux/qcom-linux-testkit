#!/bin/sh
# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

#Source init_env and functestlib.sh
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
INIT_ENV=""
SEARCH="$SCRIPT_DIR"
while [ "$SEARCH" != "/" ]; do
    if [ -f "$SEARCH/init_env" ]; then
        INIT_ENV="$SEARCH/init_env"
        break
    fi
    SEARCH=$(dirname "$SEARCH")
done

if [ -z "$INIT_ENV" ]; then
    echo "[ERROR] Could not find init_env (starting at $SCRIPT_DIR)" >&2
    exit 1
fi

# Only source if not already loaded (idempotent)
if [ -z "$__INIT_ENV_LOADED" ]; then
    # shellcheck disable=SC1090
    . "$INIT_ENV"
    __INIT_ENV_LOADED=1
fi
# ----------------------------------------------------------------------
#  Source the environment and helper libraries.
# ----------------------------------------------------------------------
# shellcheck disable=SC1091
. "$TOOLS/functestlib.sh"

# shellcheck disable=SC1091
. "$TOOLS/lib_gstreamer.sh"

# ----------------------------------------------------------------------
#  Constants & defaults (can be overridden via CLI)
# ----------------------------------------------------------------------
TESTNAME="AI_ML"
RES_FILE="./${TESTNAME}.res"
# ----------------------------------------------------------------------
#  Locate test case directory
# ----------------------------------------------------------------------
test_path=$(find_test_case_by_name "${TESTNAME}")
log_info "test path is ${test_path}"
if ! cd "${test_path}"; then
    log_error "Unable to cd to test directory: ${test_path}"
    echo "$TESTNAME FAIL" > "$RES_FILE"
    exit 0
fi
TIMEOUT=60 # seconds
# ENCODED_VIDEO_PATH=''"${test_path}"'/video_out.mp4'
ENCODED_VIDEO_PATH='./video_out.mp4'
GST_DEBUG_LEVEL=2
# ----------------------------------------------------------------------
#  GStreamer pipelines
# ----------------------------------------------------------------------
DETECTION_PIPELINE='filesrc location='"${test_path}"'/assets/video.mp4 ! qtdemux ! queue ! h264parse ! v4l2h264dec capture-io-mode=4 output-io-mode=4 ! queue ! tee name=split split. ! queue ! qtivcomposer name=mixer ! queue ! waylandsink sync=true fullscreen=true split. ! queue ! qtimlvconverter ! queue ! qtimltflite delegate=external external-delegate-path=libQnnTFLiteDelegate.so external-delegate-options="QNNExternalDelegate,backend_type=htp;" model='"${test_path}"'/assets/yolox_quantized.tflite ! queue ! qtimlpostprocess module=yolov8 labels='"${test_path}"'/assets/labels_ga16/labels/yolox.json settings="{\"confidence\": 50.0}" ! video/x-raw,format=BGRA,width=640,height=360 ! queue ! mixer.'
# gst-launch-1.0 -e 
CLASSIFICATION_PIPELINE='filesrc location='"${test_path}"'/assets/video.mp4 ! qtdemux ! queue ! h264parse ! v4l2h264dec capture-io-mode=4 output-io-mode=4 ! video/x-raw,format=NV12_Q08C ! queue ! tee name=split ! queue ! qtimetamux name=metamux ! queue ! qtivoverlay ! queue ! v4l2h264enc capture-io-mode=4 output-io-mode=5 ! h264parse ! queue ! mp4mux ! queue ! filesink location='"${ENCODED_VIDEO_PATH}"' split. ! queue ! qtimlvconverter ! queue ! qtimltflite delegate=external external-delegate-path=libQnnTFLiteDelegate.so external-delegate-options="QNNExternalDelegate,backend_type=htp;" model='"${test_path}"'/assets/inception_v3_quantized.tflite ! queue ! qtimlpostprocess results=5 module=mobilenet-softmax labels='"${test_path}"'/assets/labels_ga15/labels/imagenet_labels.txt settings="{\"confidence\": 31.0}" ! text/x-raw ! queue ! metamux.'

# ----------------------------------------------------------------------
#  Helper functions
# ----------------------------------------------------------------------
usage() {
    exit_code=0
    if [ "$#" -gt 0 ]; then
        printf 'Error: %s\n\n' "$1" >&2
        exit_code=2
    fi
    cat <<'EOF'
Usage: run.sh [options]

Options:
  --timeout <seconds>        Maximum time a GStreamer pipeline may run.
                             Default: 60 seconds
  --gstdebug <level>         GST_DEBUG level (numeric). Default: 2
  --output-video <path>      Path for the encoded video generated by the
                             classification pipeline.
                             Default: /test_path/video_out.mp4
  -h, --help                 Show this help message and exit.
EOF
    exit "${exit_code}"
}

# ----------------------------------------------------------------------
#  Pull all required TFLite models / assets.
# ----------------------------------------------------------------------
download_model_artifacts() {
    # ------------------------------------------------------------------
    # Optional: make sure we have network connectivity (kept from the
    # original script)
    # ------------------------------------------------------------------
    if command -v ensure_network_online >/dev/null 2>&1; then
        if ! ensure_network_online; then
            log_skip "Network offline/limited; cannot fetch assets"
            return 1
        fi
    fi

    log_info "Network is online, proceed to download!"
    out=''"${test_path}"'/assets'
    mkdir -p "${out}"

    # ------------------------------------------------------------------
    # Download the regular (non-zip) assets with download_resource
    # ------------------------------------------------------------------
    log_info "Downloading Inception-v3 model..."
    download_resource \
        "https://huggingface.co/qualcomm/Inception-v3/resolve/ba8121b0a74c7e28b45b250064c26efc7e7da29e/Inception-v3_w8a8.tflite" \
        "${out}/inception_v3_quantized.tflite" >/dev/null

    log_info "Downloading YoloX model..."
    download_resource \
        "https://huggingface.co/qualcomm/Yolo-X/resolve/v0.30.5/Yolo-X_w8a8.tflite" \
        "${out}/yolox_quantized.tflite" >/dev/null

    log_info "Downloading sample video..."
    download_resource \
        "https://raw.githubusercontent.com/quic/sample-apps-for-qualcomm-linux/refs/heads/main/artifacts/videos/video.mp4" \
        "${out}/video.mp4" >/dev/null

    # ------------------------------------------------------------------
    # Download zip-files (labels) and extract them
    # ------------------------------------------------------------------
    log_info "Downloading labels (set 1)…"
    zip_path=$(download_resource \
        "https://github.com/quic/sample-apps-for-qualcomm-linux/releases/download/GA1.5-rel/labels.zip" \
        "${out}/labels_ga15.zip")   
    extract_zip_to_dir "${zip_path}" "${out}/labels_ga15"

    log_info "Downloading labels (set 2)…"
    zip_path=$(download_resource \
        "https://github.com/quic/sample-apps-for-qualcomm-linux/releases/download/GA1.6-labels/labels.zip" \
        "${out}/labels_ga16.zip")
    extract_zip_to_dir "${zip_path}" "${out}/labels_ga16"
}

# ----------------------------------------------------------------------
#  Argument parsing
# ----------------------------------------------------------------------
while [ "$#" -gt 0 ]; do
    case "$1" in
        --timeout)
            shift
            if [ "$#" -eq 0 ] || [ "${1#-}" != "$1" ]; then
                usage "Missing value for --timeout"
            fi
            TIMEOUT=$1
            ;;
        --gstdebug)
            shift
            if [ "$#" -eq 0 ] || [ "${1#-}" != "$1" ]; then
                usage "Missing value for --gstdebug"
            fi
            GST_DEBUG_LEVEL=$1
            ;;
        --output-video)
            shift
            if [ "$#" -eq 0 ] || [ "${1#-}" != "$1" ]; then
                usage "Missing value for --output-video"
            fi
            ENCODED_VIDEO_PATH=$1
            ;;
        -h|--help)
            usage
            ;;
        *)
            usage "Unknown argument: $1"
            ;;
    esac
    shift
done

# ----------------------------------------------------------------------
#  Wayland environment handling
# ----------------------------------------------------------------------
log_info "Setting up Wayland environment"
if command -v weston_pick_env_or_start >/dev/null 2>&1; then
    log_info "Checking if Weston socket exists; if not, stop+start Weston and adopt helper socket."
    if ! weston_pick_env_or_start; then
        log_fail "Failed to adopt Wayland env"
        echo "$TESTNAME FAIL" > "$RES_FILE"
        exit 0
    fi
fi

# ----------------------------------------------------------------------
#  Start of test execution
# ----------------------------------------------------------------------
log_info "--------------------------------------------------------------------------"
log_info "------------------- Starting ${TESTNAME} Testcase ------------------------"

# ----------------------------------------------------------------------
#  Verify required GStreamer elements for both pipelines
# ----------------------------------------------------------------------
if ! check_pipeline_elements "${DETECTION_PIPELINE}"; then
    log_skip "${TESTNAME} SKIP - Object-Detection pipeline missing elements"
    echo "$TESTNAME SKIP" > "$RES_FILE"
    exit 0
fi

if ! check_pipeline_elements "${CLASSIFICATION_PIPELINE}"; then
    log_skip "${TESTNAME} SKIP - Image-Classification pipeline missing elements"
    echo "$TESTNAME SKIP" > "$RES_FILE"
    exit 0
fi

# ----------------------------------------------------------------------
#  Pull required model / media assets
# ----------------------------------------------------------------------
log_info "Downloading required models/assets"
if ! download_model_artifacts; then
    log_skip "${TESTNAME} SKIP - Failed fetching assets online!"
    echo "$TESTNAME SKIP" > "$RES_FILE"
    exit 0
fi

# ----------------------------------------------------------------------
#  Set GStreamer debug level (environment variable)
# ----------------------------------------------------------------------
export GST_DEBUG="${GST_DEBUG_LEVEL}"
log_info "GStreamer debug level set to ${GST_DEBUG_LEVEL}"
log_info "Setting timeout to ${TIMEOUT} seconds"
log_info "Creating logs directory"
GST_LOGS_DIR=''"${test_path}"'/logs'
mkdir -p "${GST_LOGS_DIR}"

# ----------------------------------------------------------------------
#  Run both pipelines (object detection + image classification)
# ----------------------------------------------------------------------
overall_success=1

if run_pipeline_with_logs "object_detection" "${DETECTION_PIPELINE}" "${TIMEOUT}"; then
    log_pass "Object-Detection pipeline completed successfully"
else
    overall_success=0
    log_fail "Object-Detection pipeline failed"
fi

if run_pipeline_with_logs "image_classification" "${CLASSIFICATION_PIPELINE}" "${TIMEOUT}"; then
    log_pass "Image-Classification pipeline completed successfully"

    # Verify that the encoded video file was produced
    log_info "Checking encoded video file: ${ENCODED_VIDEO_PATH}"
    expected=1048576
    if check_file_size "${ENCODED_VIDEO_PATH}" "$expected"; then
        log_pass "${ENCODED_VIDEO_PATH} is present and non-empty"
    else
        overall_success=0
        log_fail "${ENCODED_VIDEO_PATH} is empty or cannot be accessed"
    fi
else
    overall_success=0
    log_fail "Image-Classification pipeline failed"
fi

# ----------------------------------------------------------------------
#  Final result handling
# ----------------------------------------------------------------------
if [ "$overall_success" -eq 1 ]; then
    log_pass "Both pipelines executed successfully."
    echo "$TESTNAME PASS" > "$RES_FILE"
    exit 0
else
    log_fail "One or more pipelines failed."
    echo "$TESTNAME FAIL" > "$RES_FILE"
    exit 0
fi