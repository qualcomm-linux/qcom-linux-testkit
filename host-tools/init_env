#!/bin/sh

# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# Idempotency guard: only initialize ONCE per shell session
[ -n "$__INIT_ENV_LOADED" ] && return
__INIT_ENV_LOADED=1

# --- Robust root detection for host-tools ---
if [ -z "$ROOT_DIR" ]; then
    # When sourced, we need to find the directory containing this init_env file
    # Try multiple methods to get the script location
    if [ -n "${BASH_SOURCE:-}" ]; then
        # Bash
        _script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    elif [ -n "${ZSH_VERSION:-}" ]; then
        # Zsh
        _script_dir="$(cd "$(dirname "${(%):-%x}")" && pwd)"
    else
        # POSIX fallback: assume init_env is in a known location relative to caller
        # The caller (run.sh) sets INIT_ENV variable before sourcing
        if [ -n "${INIT_ENV:-}" ]; then
            _script_dir="$(cd "$(dirname "$INIT_ENV")" && pwd)"
        else
            _script_dir="$(cd "$(dirname "$0")" && pwd)"
        fi
    fi
    
    # For host-tools, ROOT_DIR is the host-tools directory itself
    if [ -d "$_script_dir/utils" ] && [ -f "$_script_dir/utils/functestlib.sh" ]; then
        ROOT_DIR="$_script_dir"
    else
        echo "[ERROR] Could not detect host-tools root (missing utils/ or functestlib.sh)" >&2
        echo "[DEBUG] Tried _script_dir=$_script_dir" >&2
        exit 1
    fi
fi

# --- Validate and export key environment paths ---
if [ -z "${ROOT_DIR:-}" ] || [ ! -d "$ROOT_DIR/utils" ] || [ ! -f "$ROOT_DIR/utils/functestlib.sh" ]; then
    echo "[ERROR] Could not detect host-tools root (missing utils/ or functestlib.sh)" >&2
    exit 1
fi

export ROOT_DIR
export TOOLS="$ROOT_DIR/utils"
export __RUNNER_SUITES_DIR="$ROOT_DIR"
export __RUNNER_UTILS_BIN_DIR="$ROOT_DIR/common"

# --- Ensure TOOLS is usable in all shells ---
case ":$PATH:" in
  *":$TOOLS:"*) : ;;
  *)
    PATH="$TOOLS:$PATH"
    export PATH
    ;;
esac

# --- Source functestlib.sh to make functions available ---
if [ -f "$TOOLS/functestlib.sh" ]; then
    # shellcheck disable=SC1090,SC1091
    . "$TOOLS/functestlib.sh"
fi

###############################################################################
# Stdout/stderr capture (per-test folder)
#
# Controls (set BEFORE sourcing this file):
# RUN_STDOUT_ENABLE = 1 | 0 (default: 1)
# RUN_STDOUT_TAG = <string> (default: basename of $PWD)
# RUN_STDOUT_FILE = <path> (default: $PWD/<tag>_stdout_<ts>.log)
#
# Behavior:
# - Writes the capture file into the CURRENT DIRECTORY (usually the test dir).
# - No global logs/stdout directory is created/used.
###############################################################################
_runner_stdout_cleanup() {
    st=$?
    # restore original fds (if they were saved)
    exec 1>&3 2>&4
    if [ -n "${__TEE_PID:-}" ]; then
        kill "$__TEE_PID" 2>/dev/null
    fi
    if [ -n "${PIPE:-}" ]; then
        rm -f "$PIPE" 2>/dev/null
    fi
    exit "$st"
}

if [ "${RUN_STDOUT_ENABLE:-1}" -eq 1 ] && [ -z "${__RUN_STDOUT_ACTIVE:-}" ]; then
    _tag="${RUN_STDOUT_TAG:-$(basename "$(pwd)")}"
    _ts="$(date +%Y%m%d-%H%M%S)"
    RUN_STDOUT_FILE="${RUN_STDOUT_FILE:-$(pwd)/${_tag}_stdout_${_ts}.log}"
    export RUN_STDOUT_FILE

    # Save original stdout/stderr
    exec 3>&1 4>&2

    if command -v tee >/dev/null 2>&1; then
        PIPE="$(mktemp -u "/tmp/stdout_pipe.XXXXXX")"
        if mkfifo "$PIPE" 2>/dev/null; then
            ( tee -a "$RUN_STDOUT_FILE" >&3 ) < "$PIPE" &
            __TEE_PID=$!
            exec > "$PIPE" 2>&1
            __RUN_STDOUT_ACTIVE=1
            trap _runner_stdout_cleanup EXIT INT TERM
        else
            # Fallback: file-only capture
            exec >> "$RUN_STDOUT_FILE" 2>&1
            __RUN_STDOUT_ACTIVE=1
            trap _runner_stdout_cleanup EXIT INT TERM
        fi
    else
        # Fallback: file-only capture
        exec >> "$RUN_STDOUT_FILE" 2>&1
        __RUN_STDOUT_ACTIVE=1
        trap _runner_stdout_cleanup EXIT INT TERM
    fi
fi
